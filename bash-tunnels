#!/usr/bin/env bash
# This script was generated by bashly 1.3.2 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
bash_tunnels_usage() {
  printf "bash-tunnels - A simple bash application to manage and create SSH tunnels in a remote VPS.\n\n"

  printf "%s\n" "Usage:"
  printf "  bash-tunnels COMMAND\n"
  printf "  bash-tunnels [COMMAND] --help | -h\n"
  printf "  bash-tunnels --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Add a new VPS\n" "add_vps      "
  printf "  %s   List all the available VPS\n" "list_vps     "
  printf "  %s   Add a new tunnel into an existing VPS\n" "add_tunnel   "
  printf "  %s   List all tunnels created by bash-tunnel\n" "list_tunnels "
  printf "  %s   Check the status of a specific tunnel\n" "status_tunnel"
  printf "  %s   Shows the public SSH key and instructions on how to add it on the remote VPS.\n" "show_key     "
  printf "  %s   Completely remove bash-tunnels from your system\n" "uninstall    "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
bash_tunnels_add_vps_usage() {
  printf "bash-tunnels add_vps - Add a new VPS\n\n"
  printf "Alias: av\n"
  echo

  printf "%s\n" "Usage:"
  printf "  bash-tunnels add_vps [OPTIONS]\n"
  printf "  bash-tunnels add_vps --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--vps_name, -n VPS_NAME"
    printf "    A unique name for the VPS (e.g., my_vps)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--vps_ip, -i VPS_IP"
    printf "    The IP address to login at your VPS\n"
    echo

    # :flag.usage
    printf "  %s\n" "--vps_user, -u VPS_USER"
    printf "    The user to login at your VPS\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ssh_port, -p SSH_PORT"
    printf "    The port to login at your VPS\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bash-tunnels --vps_name=my_vps --vps_ip=127.0.0.1 --vps_user=root\n  --ssh_port=22\n"
    printf "  bash-tunnels\n"
    printf "  bash-tunnels -n=my_vps -i=127.0.0.1 -u=root -p=22\n"
    echo

  fi
}

# :command.usage
bash_tunnels_list_vps_usage() {
  printf "bash-tunnels list_vps - List all the available VPS\n\n"
  printf "Alias: lv\n"
  echo

  printf "%s\n" "Usage:"
  printf "  bash-tunnels list_vps\n"
  printf "  bash-tunnels list_vps --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bash-tunnels l\n"
    printf "  bash-tunnels list_vps\n"
    echo

  fi
}

# :command.usage
bash_tunnels_add_tunnel_usage() {
  printf "bash-tunnels add_tunnel - Add a new tunnel into an existing VPS\n\n"
  printf "Alias: at\n"
  echo

  printf "%s\n" "Usage:"
  printf "  bash-tunnels add_tunnel [OPTIONS]\n"
  printf "  bash-tunnels add_tunnel --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--vps_name, -n VPS_NAME"
    printf "    The VPS name to connect the tunnel\n"
    echo

    # :flag.usage
    printf "  %s\n" "--local_port, -l LOCAL_PORT"
    printf "    The local port. This should be the port where your service is running\n    locally\n"
    echo

    # :flag.usage
    printf "  %s\n" "--remote_port, -r REMOTE_PORT"
    printf "    The remote port. This should be the port where your service will be\n    accessible on the VPS\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bash-tunnels add_tunnel --vps_name=my_vps --local_port=3000 --remote_port=3000\n"
    printf "  bash-tunnels at\n"
    printf "  bash-tunnels add_tunnel -n=my_vps -l=3000 -r=3000\n"
    echo

  fi
}

# :command.usage
bash_tunnels_list_tunnels_usage() {
  printf "bash-tunnels list_tunnels - List all tunnels created by bash-tunnel\n\n"
  printf "Alias: lt\n"
  echo

  printf "%s\n" "Usage:"
  printf "  bash-tunnels list_tunnels\n"
  printf "  bash-tunnels list_tunnels --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bash-tunnels lt\n"
    printf "  bash-tunnels list_tunnels\n"
    echo

  fi
}

# :command.usage
bash_tunnels_status_tunnel_usage() {
  printf "bash-tunnels status_tunnel - Check the status of a specific tunnel\n\n"
  printf "Alias: st\n"
  echo

  printf "%s\n" "Usage:"
  printf "  bash-tunnels status_tunnel [OPTIONS]\n"
  printf "  bash-tunnels status_tunnel --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--tunnel_name, -n TUNNEL_NAME"
    printf "    The tunnel name. You can get it using the list_tunnels command\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bash-tunnels st -n=bash-tunnels-my_vps\n"
    printf "  bash-tunnels status_tunnel --tunnel_name=bash-tunnels-my_vps\n"
    echo

  fi
}

# :command.usage
bash_tunnels_show_key_usage() {
  printf "bash-tunnels show_key - Shows the public SSH key and instructions on how to add it on the remote VPS.\n\n"
  printf "Alias: sk\n"
  echo

  printf "%s\n" "Usage:"
  printf "  bash-tunnels show_key\n"
  printf "  bash-tunnels show_key --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bash-tunnels sk\n"
    printf "  bash-tunnels show_key\n"
    echo

  fi
}

# :command.usage
bash_tunnels_uninstall_usage() {
  printf "bash-tunnels uninstall - Completely remove bash-tunnels from your system\n\n"
  printf "Alias: ut\n"
  echo

  printf "%s\n" "Usage:"
  printf "  bash-tunnels uninstall\n"
  printf "  bash-tunnels uninstall --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bash-tunnels ut\n"
    printf "  bash-tunnels uninstall\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
enable_auto_colors() {
  if [[ -z ${NO_COLOR+x} && ! -t 1 ]]; then
    NO_COLOR=1
  fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ "${NO_COLOR:-}" == "" ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

# src/lib/setup_permissions.sh

# Set ownership and permissions
setup_permissions(){
    actual_user=$(basename "$user_home")
    chown -R $actual_user:$actual_user "$PROJECT_DIR"
    green "Permissions set for $PROJECT_DIR."

}

# src/lib/structure_setup.sh
#Initial setup and global variables

# Get the real user's home directory (not root's)
if [[ -n "$SUDO_USER" ]]; then
    user_home=$(getent passwd "$SUDO_USER" | cut -d: -f6)
else
    user_home="$HOME"
fi
PROJECT_DIR="$user_home/.bash-tunnels"
SSH_KEY_PATH="$PROJECT_DIR/id_ed25519"
VPS_FILE="$PROJECT_DIR/vps.txt"
SERVICE_DIR="/etc/systemd/system"

# Check if root
if [[ $EUID -ne 0 ]]; then
    echo "bash-tunnels: This script must be run as root (use sudo)."
    exit 1
fi

setup_key() {
    # Create project directory if it doesn't exist
    mkdir -p "$PROJECT_DIR"

    # Generate SSH key if it doesn't exist
    if [[ ! -f "$SSH_KEY_PATH" ]]; then
        yellow "Generating Ed25519 SSH key..."
        ssh-keygen -t ed25519 -f "$SSH_KEY_PATH" -N "" >/dev/null 2>&1  # Suppress output
        green_bold "Key generated successfully at $SSH_KEY_PATH."
        green_underlined "Add the following public key to the external server:"
        cyan "$(cat "${SSH_KEY_PATH}.pub")"
    else
        yellow "SSH key already exists at $SSH_KEY_PATH."
    fi
}

# src/lib/validations.sh
# Validate name
validate_name() {
    local name="$1"  # Use the passed argument
    if [[ -z "$name" ]] || [[ "$name" =~ [[:space:]] ]] || grep -q "^${name}," "$VPS_FILE" 2>/dev/null; then
        red "Invalid or duplicate name (must be non-empty and no spaces)."
        return 1
    fi
}

# Validate IP
validate_ip() {
    local ip="$1"
    # Basic regex for IPv4 or IPv6 (supports compressed IPv6 like ::1)
    if [[ -z "$ip" ]] || ! [[ "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$|^([0-9a-fA-F]{1,4}:){1,7}[0-9a-fA-F]{1,4}$|^::1$|^::$ ]]; then
        red "Invalid IP address (must be non-empty and a valid IPv4 or IPv6 format)."
        return 1
    else
        return 0
    fi
}

# Validate user
validate_user() {
    local user="$1"
    if [[ -z "$user" ]] || [[ "$user" =~ [[:space:]] ]] || ! [[ "$user" =~ ^[a-zA-Z0-9_.-]+$ ]]; then
        red "Invalid username (must be non-empty, no spaces, and contain only letters, numbers, underscores, hyphens, or dots)."
        return 1
    fi
    return 0
}

# Validate port
validate_port() {
    local port="$1"
    if [[ -z "$port" ]] || ! [[ "$port" =~ ^[0-9]+$ ]] || (( port < 1 || port > 65535 )); then
        red "Invalid SSH port (must be non-empty and a number between 1 and 65535)."
        return 1
    else
        return 0
    fi
}

# :command.command_functions
# :command.function
bash_tunnels_add_vps_command() {

  # src/add_vps_command.sh
  vps_name=${args[--vps_name]}
  vps_ip=${args[--vps_ip]}
  vps_user=${args[--vps_user]}
  ssh_port=${args[--ssh_port]}

  # Automated mode validation
  if [[ -n "$vps_name" ]] && ! validate_name "$vps_name"; then
      exit 1
  fi
  if [[ -n "$vps_ip" ]] && ! validate_ip "$vps_ip"; then
      exit 1
  fi

  if [[ -n "$vps_user" ]] && ! validate_user "$vps_user"; then
      exit 1
  fi

  if [[ -n "$ssh_port" ]] && ! validate_port "$ssh_port"; then
      exit 1
  fi

  # Interactive mode validation
  if [[ -z "$vps_name" ]]; then
      while true; do
          green "Please type a unique VPS name with no spaces:"
          read vps_name
          if validate_name "$vps_name"; then
              break
          fi
      done
  fi

  if [[ -z "$vps_ip" ]]; then
      while true; do
          green "Please type the VPS IP:"
          read vps_ip
          if validate_ip "$vps_ip"; then
              break
          fi
      done
  fi

  if [[ -z "$vps_user" ]]; then
      while true; do
          green "Please type the VPS user:"
          read vps_user
          if validate_user "$vps_user"; then
              break
          fi
      done
  fi

  if [[ -z "$ssh_port" ]]; then
      while true; do
          green "Please type the SSH port:"
          read ssh_port
          if validate_port "$ssh_port"; then
              break
          fi
      done
  fi

  # Now we can finally setup the SSH key and actually add the VPS
  setup_key #creating ssh key

  echo "${vps_name},${vps_ip},${vps_user},${ssh_port}" >> "$VPS_FILE"
  echo "bash-tunnels: VPS '${vps_name}' added."

  setup_permissions
}

# :command.function
bash_tunnels_list_vps_command() {

  # src/list_vps_command.sh
  echo "# This file is located at 'src/list_vps_command.sh'."
  echo "# It contains the implementation for the 'bash-tunnels list_vps' command."
  echo "# The code you write here will be wrapped by a function named 'bash_tunnels_list_vps_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
bash_tunnels_add_tunnel_command() {

  # src/add_tunnel_command.sh
  echo "# This file is located at 'src/add_tunnel_command.sh'."
  echo "# It contains the implementation for the 'bash-tunnels add_tunnel' command."
  echo "# The code you write here will be wrapped by a function named 'bash_tunnels_add_tunnel_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
bash_tunnels_list_tunnels_command() {

  # src/list_tunnels_command.sh
  echo "# This file is located at 'src/list_tunnels_command.sh'."
  echo "# It contains the implementation for the 'bash-tunnels list_tunnels' command."
  echo "# The code you write here will be wrapped by a function named 'bash_tunnels_list_tunnels_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
bash_tunnels_status_tunnel_command() {

  # src/status_tunnel_command.sh
  echo "# This file is located at 'src/status_tunnel_command.sh'."
  echo "# It contains the implementation for the 'bash-tunnels status_tunnel' command."
  echo "# The code you write here will be wrapped by a function named 'bash_tunnels_status_tunnel_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
bash_tunnels_show_key_command() {

  # src/show_key_command.sh
  echo "# This file is located at 'src/show_key_command.sh'."
  echo "# It contains the implementation for the 'bash-tunnels show_key' command."
  echo "# The code you write here will be wrapped by a function named 'bash_tunnels_show_key_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
bash_tunnels_uninstall_command() {

  # src/uninstall_command.sh
  echo "# This file is located at 'src/uninstall_command.sh'."
  echo "# It contains the implementation for the 'bash-tunnels uninstall' command."
  echo "# The code you write here will be wrapped by a function named 'bash_tunnels_uninstall_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        bash_tunnels_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    add_vps | av)
      action="add_vps"
      shift
      bash_tunnels_add_vps_parse_requirements "$@"
      shift $#
      ;;

    list_vps | lv)
      action="list_vps"
      shift
      bash_tunnels_list_vps_parse_requirements "$@"
      shift $#
      ;;

    add_tunnel | at)
      action="add_tunnel"
      shift
      bash_tunnels_add_tunnel_parse_requirements "$@"
      shift $#
      ;;

    list_tunnels | lt)
      action="list_tunnels"
      shift
      bash_tunnels_list_tunnels_parse_requirements "$@"
      shift $#
      ;;

    status_tunnel | st)
      action="status_tunnel"
      shift
      bash_tunnels_status_tunnel_parse_requirements "$@"
      shift $#
      ;;

    show_key | sk)
      action="show_key"
      shift
      bash_tunnels_show_key_parse_requirements "$@"
      shift $#
      ;;

    uninstall | ut)
      action="uninstall"
      shift
      bash_tunnels_uninstall_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      bash_tunnels_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bash_tunnels_add_vps_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bash_tunnels_add_vps_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="add_vps"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --vps_name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--vps_name']="$2"
          shift
          shift
        else
          printf "%s\n" "--vps_name requires an argument: --vps_name, -n VPS_NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --vps_ip | -i)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--vps_ip']="$2"
          shift
          shift
        else
          printf "%s\n" "--vps_ip requires an argument: --vps_ip, -i VPS_IP" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --vps_user | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--vps_user']="$2"
          shift
          shift
        else
          printf "%s\n" "--vps_user requires an argument: --vps_user, -u VPS_USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ssh_port | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--ssh_port']="$2"
          shift
          shift
        else
          printf "%s\n" "--ssh_port requires an argument: --ssh_port, -p SSH_PORT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bash_tunnels_list_vps_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bash_tunnels_list_vps_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list_vps"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bash_tunnels_add_tunnel_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bash_tunnels_add_tunnel_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="add_tunnel"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --vps_name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--vps_name']="$2"
          shift
          shift
        else
          printf "%s\n" "--vps_name requires an argument: --vps_name, -n VPS_NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --local_port | -l)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--local_port']="$2"
          shift
          shift
        else
          printf "%s\n" "--local_port requires an argument: --local_port, -l LOCAL_PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --remote_port | -r)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--remote_port']="$2"
          shift
          shift
        else
          printf "%s\n" "--remote_port requires an argument: --remote_port, -r REMOTE_PORT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bash_tunnels_list_tunnels_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bash_tunnels_list_tunnels_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list_tunnels"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bash_tunnels_status_tunnel_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bash_tunnels_status_tunnel_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="status_tunnel"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --tunnel_name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tunnel_name']="$2"
          shift
          shift
        else
          printf "%s\n" "--tunnel_name requires an argument: --tunnel_name, -n TUNNEL_NAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bash_tunnels_show_key_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bash_tunnels_show_key_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="show_key"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bash_tunnels_uninstall_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bash_tunnels_uninstall_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="uninstall"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "add_vps") bash_tunnels_add_vps_command ;;
    "list_vps") bash_tunnels_list_vps_command ;;
    "add_tunnel") bash_tunnels_add_tunnel_command ;;
    "list_tunnels") bash_tunnels_list_tunnels_command ;;
    "status_tunnel") bash_tunnels_status_tunnel_command ;;
    "show_key") bash_tunnels_show_key_command ;;
    "uninstall") bash_tunnels_uninstall_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
