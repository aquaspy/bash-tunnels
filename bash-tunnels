#!/usr/bin/env bash
# This script was generated by bashly 1.3.2 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
bash_tunnels_usage() {
  printf "bash-tunnels - A simple bash application to manage and create SSH tunnels in a remote VPS.\n\n"

  printf "%s\n" "Usage:"
  printf "  bash-tunnels COMMAND\n"
  printf "  bash-tunnels [COMMAND] --help | -h\n"
  printf "  bash-tunnels --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Add a new VPS\n" "add_vps      "
  printf "  %s   List all the available VPS\n" "list_vps     "
  printf "  %s   Add a new tunnel into an existing VPS\n" "add_tunnel   "
  printf "  %s   List all tunnels created by bash-tunnel\n" "list_tunnels "
  printf "  %s   Check the status of a specific tunnel\n" "status_tunnel"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
bash_tunnels_add_vps_usage() {
  printf "bash-tunnels add_vps - Add a new VPS\n\n"
  printf "Alias: av\n"
  echo

  printf "%s\n" "Usage:"
  printf "  bash-tunnels add_vps [OPTIONS]\n"
  printf "  bash-tunnels add_vps --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--vps_name, -n VPS_NAME"
    printf "    A name to remember this VPS. Don't use spaces\n"
    echo

    # :flag.usage
    printf "  %s\n" "--vps_ip, -i VPS_IP"
    printf "    The IP address to login at your VPS\n"
    echo

    # :flag.usage
    printf "  %s\n" "--vps_user, -u VPS_USER"
    printf "    The user to login at your VPS\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ssh_port, -p SSH_PORT"
    printf "    The port to login at your VPS\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bash-tunnels --vps_name=my_vps --vps_ip=127.0.0.1 --vps_user=root\n  --ssh_port=22\n"
    printf "  bash-tunnels\n"
    printf "  bash-tunnels -n=my_vps -i=127.0.0.1 -u=root -p=22\n"
    echo

  fi
}

# :command.usage
bash_tunnels_list_vps_usage() {
  printf "bash-tunnels list_vps - List all the available VPS\n\n"
  printf "Alias: lv\n"
  echo

  printf "%s\n" "Usage:"
  printf "  bash-tunnels list_vps\n"
  printf "  bash-tunnels list_vps --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bash-tunnels l\n"
    printf "  bash-tunnels list_vps\n"
    echo

  fi
}

# :command.usage
bash_tunnels_add_tunnel_usage() {
  printf "bash-tunnels add_tunnel - Add a new tunnel into an existing VPS\n\n"
  printf "Alias: at\n"
  echo

  printf "%s\n" "Usage:"
  printf "  bash-tunnels add_tunnel [OPTIONS]\n"
  printf "  bash-tunnels add_tunnel --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--vps_name, -n VPS_NAME"
    printf "    The VPS to add the tunnel\n"
    echo

    # :flag.usage
    printf "  %s\n" "--local_port, -l LOCAL_PORT"
    printf "    The local port. This should be the port where your service is running\n    locally\n"
    echo

    # :flag.usage
    printf "  %s\n" "--remote_port, -r REMOTE_PORT"
    printf "    The remote port. This should be the port where your service will be\n    accessible on the VPS\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bash-tunnels add_tunnel --vps_name=my_vps --local_port=3000 --remote_port=3000\n"
    printf "  bash-tunnels at\n"
    printf "  bash-tunnels add_tunnel -n=my_vps -l=3000 -r=3000\n"
    echo

  fi
}

# :command.usage
bash_tunnels_list_tunnels_usage() {
  printf "bash-tunnels list_tunnels - List all tunnels created by bash-tunnel\n\n"
  printf "Alias: lt\n"
  echo

  printf "%s\n" "Usage:"
  printf "  bash-tunnels list_tunnels\n"
  printf "  bash-tunnels list_tunnels --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bash-tunnels lt\n"
    printf "  bash-tunnels list_tunnels\n"
    echo

  fi
}

# :command.usage
bash_tunnels_status_tunnel_usage() {
  printf "bash-tunnels status_tunnel - Check the status of a specific tunnel\n\n"
  printf "Alias: st\n"
  echo

  printf "%s\n" "Usage:"
  printf "  bash-tunnels status_tunnel [OPTIONS]\n"
  printf "  bash-tunnels status_tunnel --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--tunnel_name, -n TUNNEL_NAME"
    printf "    The tunnel name. You can get it using the list_tunnels command\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  bash-tunnels st -n=bash-tunnels-my_vps\n"
    printf "  bash-tunnels status_tunnel --tunnel_name=bash-tunnels-my_vps\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.command_functions
# :command.function
bash_tunnels_add_vps_command() {

  # src/add_vps_command.sh
  echo "# This file is located at 'src/add_vps_command.sh'."
  echo "# It contains the implementation for the 'bash-tunnels add_vps' command."
  echo "# The code you write here will be wrapped by a function named 'bash_tunnels_add_vps_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
bash_tunnels_list_vps_command() {

  # src/list_vps_command.sh
  echo "# This file is located at 'src/list_vps_command.sh'."
  echo "# It contains the implementation for the 'bash-tunnels list_vps' command."
  echo "# The code you write here will be wrapped by a function named 'bash_tunnels_list_vps_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
bash_tunnels_add_tunnel_command() {

  # src/add_tunnel_command.sh
  echo "# This file is located at 'src/add_tunnel_command.sh'."
  echo "# It contains the implementation for the 'bash-tunnels add_tunnel' command."
  echo "# The code you write here will be wrapped by a function named 'bash_tunnels_add_tunnel_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
bash_tunnels_list_tunnels_command() {

  # src/list_tunnels_command.sh
  echo "# This file is located at 'src/list_tunnels_command.sh'."
  echo "# It contains the implementation for the 'bash-tunnels list_tunnels' command."
  echo "# The code you write here will be wrapped by a function named 'bash_tunnels_list_tunnels_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
bash_tunnels_status_tunnel_command() {

  # src/status_tunnel_command.sh
  echo "# This file is located at 'src/status_tunnel_command.sh'."
  echo "# It contains the implementation for the 'bash-tunnels status_tunnel' command."
  echo "# The code you write here will be wrapped by a function named 'bash_tunnels_status_tunnel_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        bash_tunnels_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    add_vps | av)
      action="add_vps"
      shift
      bash_tunnels_add_vps_parse_requirements "$@"
      shift $#
      ;;

    list_vps | lv)
      action="list_vps"
      shift
      bash_tunnels_list_vps_parse_requirements "$@"
      shift $#
      ;;

    add_tunnel | at)
      action="add_tunnel"
      shift
      bash_tunnels_add_tunnel_parse_requirements "$@"
      shift $#
      ;;

    list_tunnels | lt)
      action="list_tunnels"
      shift
      bash_tunnels_list_tunnels_parse_requirements "$@"
      shift $#
      ;;

    status_tunnel | st)
      action="status_tunnel"
      shift
      bash_tunnels_status_tunnel_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      bash_tunnels_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bash_tunnels_add_vps_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bash_tunnels_add_vps_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="add_vps"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --vps_name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--vps_name']="$2"
          shift
          shift
        else
          printf "%s\n" "--vps_name requires an argument: --vps_name, -n VPS_NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --vps_ip | -i)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--vps_ip']="$2"
          shift
          shift
        else
          printf "%s\n" "--vps_ip requires an argument: --vps_ip, -i VPS_IP" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --vps_user | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--vps_user']="$2"
          shift
          shift
        else
          printf "%s\n" "--vps_user requires an argument: --vps_user, -u VPS_USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ssh_port | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--ssh_port']="$2"
          shift
          shift
        else
          printf "%s\n" "--ssh_port requires an argument: --ssh_port, -p SSH_PORT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bash_tunnels_list_vps_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bash_tunnels_list_vps_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list_vps"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bash_tunnels_add_tunnel_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bash_tunnels_add_tunnel_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="add_tunnel"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --vps_name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--vps_name']="$2"
          shift
          shift
        else
          printf "%s\n" "--vps_name requires an argument: --vps_name, -n VPS_NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --local_port | -l)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--local_port']="$2"
          shift
          shift
        else
          printf "%s\n" "--local_port requires an argument: --local_port, -l LOCAL_PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --remote_port | -r)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--remote_port']="$2"
          shift
          shift
        else
          printf "%s\n" "--remote_port requires an argument: --remote_port, -r REMOTE_PORT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bash_tunnels_list_tunnels_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bash_tunnels_list_tunnels_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list_tunnels"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
bash_tunnels_status_tunnel_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        bash_tunnels_status_tunnel_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="status_tunnel"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --tunnel_name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tunnel_name']="$2"
          shift
          shift
        else
          printf "%s\n" "--tunnel_name requires an argument: --tunnel_name, -n TUNNEL_NAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "add_vps") bash_tunnels_add_vps_command ;;
    "list_vps") bash_tunnels_list_vps_command ;;
    "add_tunnel") bash_tunnels_add_tunnel_command ;;
    "list_tunnels") bash_tunnels_list_tunnels_command ;;
    "status_tunnel") bash_tunnels_status_tunnel_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
